# Second Part One complete Integration Absence

## üßë‚Äçüíª **Qualitative Metrics (Expert Review)**

Three developers will evaluate the generated artifacts using a standardized questionnaire based on a Likert scale (1 = very poor, 5 = excellent).

## **üìù Evaluation Form for Experts**

**Instructions:** Please evaluate the following artifacts that were generated by an AI system for automated API integration.

---

## **Part 1: Code Quality Evaluation (Generated Kotlin Code)**

| Criterion | Rating (1-5) | Comment |
| --- | --- | --- |
| **1.1 Readability & Structure:** The code is clear, logical, and understandable. | 4 | Commented out code should not be committed. Unused code should not be committed. Some code can be omitted because it‚Äôs redundant with the default values. |
| **1.2 Maintainability:** The code is modular and well-commented. | 3 | There are superfluous comments, and there is no javadoc at all. This section could be replaced with a map of values (keywords that map to a corresponding type), and there could be just one function that iterates through the map and builds the dto. |
| **1.3 Naming Conventions:** Variables, functions, etc. are meaningfully named. | 4 | `fmt` could be `dateFormat`, while `startIso` and `endIso` could be `startDateIso` and `endDateIso` |
| **1.4 Error Handling:** The code contains robust error handling. | 3 | There are error statements here and there, but they are not clearly translated into corresponding HTTP responses in the controller methods. My personal preference is to not write exception driven code, but rather use more versatile types (e.g. something like Either in Scala) and control the flow explicitly and precisely. |

---

## **Part 2: Explainability & Documentation Evaluation**

| Criterion | Rating (1-5) | Comment |
| --- | --- | --- |
| **2.1 Clarity of Mapping Rationales:** The reasons for mappings are logical and comprehensible. | 4 | At first sight, yet. Though the AI might lack specific knowledge. StackOne, as well as the underlying HR providers, have a lot of bugs and varying behavior in a number of cases that is not insignificant. This would have to be an iterative process where someone or something is in constant human-like communication with the providers of APIs, resolving issues and incorporating new things. |
| **2.2 Quality of Code Comments:** The comments are helpful and precise. | 3 | Extensive comments mean that I have to read a lot. I could‚Äôve wrote the code myself during that time. Short comments are often unnecessary. The common ground might be  that occasional comments for certain complex mappings might be useful, while comments for simple mappings don‚Äôt have to exist at all.   |
| **2.3 Completeness of Process Documentation:** The planning files and reports.md files (e.g., `PLANNING.md`) provide a complete overview. | 4 | Since LLMs are used already, the output should look and feel more human-readable and less formal. Now it feels like there‚Äôs too much information. Most info can be in expandable sections collapsed by default. If *.md format is not suitable, consider other options.  |
| **2.4 Traceability of Overall Process:** The process from specification to code is comprehensible. | 4 | Technically, it might be comprehensible, but it still feels too formal and rigid considering that LLMs should be able to interpret a more ‚Äúhuman‚Äù (i.e. less structured) input. |

---

## **Part 3: Overall Impression and Trust**

Description: (Just replace mark the field with an X where you think it is)

| Statement | Strongly Disagree (1) | (2) | (3) | (4) | Strongly Agree (5) |
| --- | --- | --- | --- | --- | --- |
| **3.1 Trust:** I would trust the generated code (after a review) in a production system. |  | X |  |  |  |
| **3.2 Added Value:** The system provides significant added value compared to manual implementation. |  |  | X |  |  |
| **3.3 Separation:** Controller/Service/Mapper are properly separated. |  |  |  | X |  |

---

## **Final Remarks:**

*(Space for open feedback, improvement suggestions, or special observations)*

Within our scope*,* StackOne provides a unified API towards many HR providers. It happens that a seemigly rock-solid implementation falters when applied to a new provider due to various issues in that provider‚Äôs own API, StackOne‚Äôs mappings and API outputs, and Flip‚Äôs interpretation of said results. Writing the mapping code feels most trivial out of all other problems that a developer is facing in this domain. While it‚Äôs a good topic for a thesis, it might not yet be that relevant in practice/production. Currently, the biggest value for me would be a QA assistant/agent that is constantly re-evaluating and testing my code, keeping up with the changes in the APIs that my code depends on, and suggesting changes and/or inquiries towards StackOne.